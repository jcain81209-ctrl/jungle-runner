<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Jungle Runner Engine Rebuild</title>
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    min-height: 100vh;
    display: grid;
    place-items: center;
    background: radial-gradient(circle at 50% 10%, #21462a, #0b120d 72%);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }
  canvas {
    display: block;
    width: min(96vw, 1200px);
    height: auto;
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 14px;
    box-shadow: 0 24px 80px rgba(0,0,0,0.6);
  }
</style>
</head>
<body>
<canvas id="game" width="960" height="540"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const config = {
  horizon: 108,
  cameraDepth: 380,
  roadWidth: 730,
  laneCount: 3,
  segmentLength: 150,
  drawDistance: 4300,
  initialSpeed: 430,
  maxSpeed: 920,
  accel: 86,
  spawnMin: 950,
  spawnMax: 1700,
};

const lanes = [-1, 0, 1];

const imagePaths = {
  background: "assets/background.png",
  road: "assets/road.png",
  player: "assets/player.png",
  tree: "assets/tree.png",
  wall: "assets/wall.png",
  gap: "assets/gap.png",
  coin: "assets/coin.png",
  magnet: "assets/magnet.png",
  shield: "assets/shield.png",
};

const images = {};
const imageStatus = {};

function loadAssets(paths) {
  const jobs = Object.entries(paths).map(([key, src]) => new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      images[key] = img;
      imageStatus[key] = "loaded";
      resolve();
    };
    img.onerror = () => {
      imageStatus[key] = "failed";
      resolve();
    };
    img.src = src;
  }));
  return Promise.all(jobs);
}

const game = {
  running: true,
  score: 0,
  coins: 0,
  distance: 0,
  speed: config.initialSpeed,
  best: Number(localStorage.getItem("jungleRunnerBest") || 0),
  nextSpawnZ: 1200,
  time: 0,
  magnetTime: 0,
  shieldTime: 0,
};

const player = {
  laneIndex: 1,
  laneVisual: 0,
  laneSwitchSpeed: 9,
  y: 0,
  velocityY: 0,
  jumpVelocity: -1060,
  gravity: 2500,
  jumpCut: 0.44,
  grounded: true,
  invulnTime: 1,
};

const entities = [];
let previousTime = performance.now();

function randomRange(min, max) { return min + Math.random() * (max - min); }
function approach(a, b, amount) {
  if (a < b) return Math.min(a + amount, b);
  if (a > b) return Math.max(a - amount, b);
  return a;
}

function project(worldX, worldZ) {
  const scale = config.cameraDepth / (config.cameraDepth + Math.max(worldZ, -config.cameraDepth + 1));
  return {
    scale,
    x: canvas.width * 0.5 + worldX * scale,
    y: config.horizon + worldZ * scale,
  };
}

function laneOffset(v) {
  return v * (config.roadWidth / config.laneCount);
}

function spawnEntity(type, lane, z, variant = "") {
  entities.push({ type, lane, z, variant, collected: false });
}

function spawnPattern() {
  const lane = lanes[Math.floor(Math.random() * lanes.length)];

  const obstacleRoll = Math.random();
  if (obstacleRoll < 0.45) spawnEntity("obstacle", lane, game.nextSpawnZ, "tree");
  else if (obstacleRoll < 0.75) spawnEntity("obstacle", lane, game.nextSpawnZ, "wall");
  else spawnEntity("obstacle", lane, game.nextSpawnZ, "gap");

  if (Math.random() > 0.2) {
    const coinLane = lanes[Math.floor(Math.random() * lanes.length)];
    const count = Math.floor(randomRange(3, 6));
    for (let i = 0; i < count; i++) {
      spawnEntity("coin", coinLane, game.nextSpawnZ + 160 + i * 95);
    }
  }

  if (Math.random() > 0.72) {
    const pLane = lanes[Math.floor(Math.random() * lanes.length)];
    const variant = Math.random() > 0.5 ? "magnet" : "shield";
    spawnEntity("powerup", pLane, game.nextSpawnZ + 240, variant);
  }

  game.nextSpawnZ += randomRange(config.spawnMin, config.spawnMax);
}

function resetGame() {
  game.running = true;
  game.score = 0;
  game.coins = 0;
  game.distance = 0;
  game.speed = config.initialSpeed;
  game.nextSpawnZ = 1200;
  game.time = 0;
  game.magnetTime = 0;
  game.shieldTime = 0;
  entities.length = 0;

  player.laneIndex = 1;
  player.laneVisual = 0;
  player.y = 0;
  player.velocityY = 0;
  player.grounded = true;
  player.invulnTime = 1.2;

  for (let i = 0; i < 4; i++) spawnPattern();
}

function updatePlayer(dt) {
  const laneTarget = lanes[player.laneIndex];
  player.laneVisual = approach(player.laneVisual, laneTarget, player.laneSwitchSpeed * dt);

  player.velocityY += player.gravity * dt;
  player.y += player.velocityY * dt;

  if (player.y >= 0) {
    player.y = 0;
    player.velocityY = 0;
    player.grounded = true;
  }

  player.invulnTime = Math.max(0, player.invulnTime - dt);
}

function hitObstacle(entity) {
  const hitGap = entity.variant === "gap";
  const canIgnore = game.shieldTime > 0 || player.invulnTime > 0;
  const jumped = player.y < -30;
  if (hitGap ? !jumped : jumped) return false;
  return !canIgnore;
}

function updateWorld(dt) {
  if (!game.running) return;

  game.time += dt;
  game.speed = Math.min(config.maxSpeed, game.speed + config.accel * dt);
  const dz = game.speed * dt;

  game.distance += dz;
  game.score += dz * 0.1;
  game.magnetTime = Math.max(0, game.magnetTime - dt);
  game.shieldTime = Math.max(0, game.shieldTime - dt);

  for (const e of entities) {
    e.z -= dz;

    if (e.type === "coin" && game.magnetTime > 0) {
      const laneDiff = Math.abs(e.lane - player.laneVisual);
      if (e.z < 430 && laneDiff < 1.5) {
        e.lane = approach(e.lane, player.laneVisual, dt * 3.5);
      }
    }
  }

  while (game.nextSpawnZ < config.drawDistance) spawnPattern();

  for (const e of entities) {
    if (e.collected) continue;

    const laneMatch = Math.abs(e.lane - player.laneVisual) < 0.45;
    const nearPlayer = e.z < 120 && e.z > -38;
    if (!laneMatch || !nearPlayer) continue;

    if (e.type === "coin") {
      e.collected = true;
      game.coins += 1;
      game.score += 60;
    } else if (e.type === "powerup") {
      e.collected = true;
      if (e.variant === "magnet") game.magnetTime = Math.max(game.magnetTime, 7);
      if (e.variant === "shield") game.shieldTime = Math.max(game.shieldTime, 6);
    } else if (e.type === "obstacle" && hitObstacle(e)) {
      game.running = false;
      game.best = Math.max(game.best, Math.floor(game.score));
      localStorage.setItem("jungleRunnerBest", String(game.best));
    }
  }

  for (let i = entities.length - 1; i >= 0; i--) {
    if (entities[i].z < -260 || entities[i].collected) entities.splice(i, 1);
  }
}

function imageReady(key) {
  return imageStatus[key] === "loaded" && images[key] && images[key].naturalWidth > 0;
}

function drawSprite(key, x, y, w, h, fallback = "#888") {
  if (imageReady(key)) {
    ctx.drawImage(images[key], x, y, w, h);
  } else {
    ctx.fillStyle = fallback;
    ctx.fillRect(x, y, w, h);
  }
}

function drawSky() {
  if (imageReady("background")) {
    drawSprite("background", 0, 0, canvas.width, canvas.height * 0.63);
  } else {
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.68);
    grad.addColorStop(0, "#4ab26d");
    grad.addColorStop(1, "#1a3a28");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height * 0.68);
  }
  ctx.fillStyle = "rgba(7,14,9,0.72)";
  ctx.fillRect(0, config.horizon + 250, canvas.width, canvas.height);
}

function drawRoad() {
  for (let z = 0; z < config.drawDistance; z += config.segmentLength) {
    const p1 = project(-config.roadWidth * 0.5, z);
    const p2 = project(config.roadWidth * 0.5, z);
    const p3 = project(-config.roadWidth * 0.5, z + config.segmentLength);
    const p4 = project(config.roadWidth * 0.5, z + config.segmentLength);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineTo(p4.x, p4.y);
    ctx.lineTo(p3.x, p3.y);
    ctx.closePath();
    ctx.clip();

    if (imageReady("road")) {
      const stripeY = ((z + game.distance * 0.9) % 320) - 320;
      drawSprite("road", p3.x, p3.y + stripeY, p4.x - p3.x, p1.y - p3.y + 400);
    } else {
      const stripe = (Math.floor((z + game.distance * 0.7) / config.segmentLength) % 2) === 0;
      ctx.fillStyle = stripe ? "#3c3a2d" : "#4b493a";
      ctx.fillRect(p3.x, p3.y, p4.x - p3.x, p1.y - p3.y);
    }
    ctx.restore();

    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.beginPath();
    ctx.moveTo((p1.x * 2 + p2.x) / 3, p1.y);
    ctx.lineTo((p3.x * 2 + p4.x) / 3, p3.y);
    ctx.moveTo((p1.x + p2.x * 2) / 3, p1.y);
    ctx.lineTo((p3.x + p4.x * 2) / 3, p3.y);
    ctx.stroke();
  }
}

function drawEntity(e) {
  const p = project(laneOffset(e.lane), e.z);

  if (e.type === "coin") {
    const s = Math.max(16, p.scale * 100);
    drawSprite("coin", p.x - s * 0.5, p.y - s * 1.1, s, s, "#ffc94a");
    return;
  }

  if (e.type === "powerup") {
    const s = Math.max(20, p.scale * 120);
    drawSprite(e.variant, p.x - s * 0.5, p.y - s * 1.15, s, s, "#4bd2c0");
    return;
  }

  const w = Math.max(32, p.scale * 185);
  const h = Math.max(42, p.scale * 205);
  drawSprite(e.variant, p.x - w * 0.5, p.y - h * 1.02, w, h, "#2b7f3c");
}

function drawPlayer() {
  const p = project(laneOffset(player.laneVisual), 0);
  const w = 88;
  const h = 106;
  const y = p.y - h + player.y;

  ctx.save();
  if (player.invulnTime > 0 && Math.floor(player.invulnTime * 18) % 2 === 0) ctx.globalAlpha = 0.45;
  if (game.shieldTime > 0) {
    ctx.strokeStyle = "rgba(117, 197, 255, 0.75)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(p.x, p.y - 48 + player.y, 45, 0, Math.PI * 2);
    ctx.stroke();
  }
  drawSprite("player", p.x - w * 0.5, y, w, h, "#f24c4c");
  ctx.restore();
}

function drawHud() {
  ctx.fillStyle = "rgba(0,0,0,0.36)";
  ctx.fillRect(16, 16, 330, 126);
  ctx.fillStyle = "#f3f6f4";
  ctx.font = "600 20px Inter, sans-serif";
  ctx.fillText(`Score: ${Math.floor(game.score)}`, 28, 44);
  ctx.fillText(`Best: ${game.best}`, 28, 70);
  ctx.fillText(`Coins: ${game.coins}`, 28, 96);

  ctx.font = "600 17px Inter, sans-serif";
  ctx.fillStyle = "#8efcc8";
  ctx.fillText(`Magnet: ${game.magnetTime > 0 ? game.magnetTime.toFixed(1) + "s" : "off"}`, 186, 70);
  ctx.fillStyle = "#8fd1ff";
  ctx.fillText(`Shield: ${game.shieldTime > 0 ? game.shieldTime.toFixed(1) + "s" : "off"}`, 186, 96);

  const failedAssets = Object.entries(imageStatus).filter(([, v]) => v === "failed").map(([k]) => k);
  if (failedAssets.length > 0) {
    ctx.fillStyle = "rgba(255, 180, 80, 0.9)";
    ctx.font = "500 14px Inter, sans-serif";
    ctx.fillText(`Missing assets: ${failedAssets.join(", ")}`, 16, canvas.height - 18);
  }

  if (!game.running) {
    ctx.fillStyle = "rgba(0,0,0,0.66)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "700 48px Inter, sans-serif";
    ctx.fillText("Run Over", canvas.width / 2, canvas.height / 2 - 40);
    ctx.font = "500 22px Inter, sans-serif";
    ctx.fillText(`Final Score: ${Math.floor(game.score)}`, canvas.width / 2, canvas.height / 2 + 4);
    ctx.fillText("Press Enter to restart", canvas.width / 2, canvas.height / 2 + 44);
    ctx.textAlign = "start";
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawSky();
  drawRoad();
  [...entities].sort((a, b) => b.z - a.z).forEach(drawEntity);
  drawPlayer();
  drawHud();
}

function frame(now) {
  const dt = Math.min(0.033, (now - previousTime) / 1000);
  previousTime = now;
  updatePlayer(dt);
  updateWorld(dt);
  draw();
  requestAnimationFrame(frame);
}

document.addEventListener("keydown", (event) => {
  if (event.code === "ArrowLeft" && game.running) {
    player.laneIndex = Math.max(0, player.laneIndex - 1);
  } else if (event.code === "ArrowRight" && game.running) {
    player.laneIndex = Math.min(config.laneCount - 1, player.laneIndex + 1);
  } else if ((event.code === "ArrowUp" || event.code === "Space") && game.running && player.grounded) {
    player.velocityY = player.jumpVelocity;
    player.grounded = false;
  } else if (event.code === "Enter" && !game.running) {
    resetGame();
  }
});

document.addEventListener("keyup", (event) => {
  if ((event.code === "ArrowUp" || event.code === "Space") && player.velocityY < 0) {
    player.velocityY *= player.jumpCut;
  }
});

loadAssets(imagePaths).then(() => {
  resetGame();
  requestAnimationFrame(frame);
});
</script>
</body>
</html>
