<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jungle Runner</title>
  <style>
    body { margin: 0; min-height: 100vh; display: grid; place-items: center; background: #0b120d; }
    canvas { width: min(96vw, 1200px); height: auto; border: 2px solid rgba(255,255,255,.22); border-radius: 14px; }
  </style>
</head>
<body>
<canvas id="game" width="960" height="540"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const cfg = {
  horizonY: 105,
  cameraDepth: 430,
  roadWidth: 740,
  segmentLength: 120,
  drawDistance: 5400,
  laneX: [-1, 0, 1],
  playerDepth: 325, // pushes player down toward the bottom
  speedStart: 230,  // slower than before
  speedMax: 520,
  accel: 35,
  spawnGapMin: 500,
  spawnGapMax: 760,
};

const imgPaths = {
  background: "assets/background.png",
  road: "assets/road.png",
  player: "assets/player.png",
  tree: "assets/tree.png",
  wall: "assets/wall.png",
  gap: "assets/gap.png",
  coin: "assets/coin.png",
  magnet: "assets/magnet.png",
  shield: "assets/shield.png"
};

const imgs = {};
const game = {
  running: true,
  speed: cfg.speedStart,
  dist: 0,
  score: 0,
  coins: 0,
  nextSpawn: 1200,
  spawnTick: 0,
  magnet: 0,
  shield: 0,
};

const player = {
  lane: 1,
  laneSmooth: 0,
  y: 0,
  vy: 0,
  grounded: true,
  jumpVel: -1030,
  gravity: 2500,
};

const entities = [];
let last = performance.now();

function loadAssets() {
  const jobs = Object.entries(imgPaths).map(([k, src]) => new Promise((res) => {
    const i = new Image();
    i.onload = () => { imgs[k] = i; res(); };
    i.onerror = () => res();
    i.src = src;
  }));
  return Promise.all(jobs);
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function rr(min, max) { return min + Math.random() * (max - min); }
function laneOffset(v) { return v * (cfg.roadWidth / 3); }

function project(worldX, relZ) {
  const z = Math.max(relZ, -cfg.cameraDepth + 1);
  const s = cfg.cameraDepth / (cfg.cameraDepth + z);
  return { x: canvas.width * 0.5 + worldX * s, y: cfg.horizonY + z * s, scale: s };
}

function addEntity(type, lane, z, variant = "") {
  entities.push({ type, lane, z, variant, dead: false });
}

function spawnWave() {
  // obstacle always
  const lane = cfg.laneX[Math.floor(Math.random() * 3)];
  const r = Math.random();
  addEntity("obstacle", lane, game.nextSpawn, r < 0.42 ? "tree" : (r < 0.82 ? "wall" : "gap"));

  // coins always
  const coinLane = cfg.laneX[Math.floor(Math.random() * 3)];
  const coinCount = 4 + Math.floor(Math.random() * 3);
  for (let i = 0; i < coinCount; i++) addEntity("coin", coinLane, game.nextSpawn + 120 + i * 90);

  // powerups continuous (every 2nd wave)
  game.spawnTick += 1;
  if (game.spawnTick % 2 === 0) {
    const pLane = cfg.laneX[Math.floor(Math.random() * 3)];
    addEntity("powerup", pLane, game.nextSpawn + 250, game.spawnTick % 4 === 0 ? "shield" : "magnet");
  }

  game.nextSpawn += rr(cfg.spawnGapMin, cfg.spawnGapMax);
}

function reset() {
  game.running = true;
  game.speed = cfg.speedStart;
  game.dist = 0;
  game.score = 0;
  game.coins = 0;
  game.nextSpawn = 1200;
  game.spawnTick = 0;
  game.magnet = 0;
  game.shield = 0;
  entities.length = 0;
  player.lane = 1;
  player.laneSmooth = 0;
  player.y = 0;
  player.vy = 0;
  player.grounded = true;
  while (game.nextSpawn < cfg.drawDistance + 1000) spawnWave();
}

function drawImageSafe(key, x, y, w, h, fallback = "#555") {
  if (imgs[key]) ctx.drawImage(imgs[key], x, y, w, h);
  else { ctx.fillStyle = fallback; ctx.fillRect(x, y, w, h); }
}

function drawRoad() {
  const start = Math.floor(game.dist / cfg.segmentLength) * cfg.segmentLength;
  const end = start + cfg.drawDistance;

  for (let z = start; z < end; z += cfg.segmentLength) {
    const near = z - game.dist;
    const far = z + cfg.segmentLength - game.dist;
    const p1 = project(-cfg.roadWidth * 0.5, near);
    const p2 = project(cfg.roadWidth * 0.5, near);
    const p3 = project(-cfg.roadWidth * 0.5, far);
    const p4 = project(cfg.roadWidth * 0.5, far);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineTo(p4.x, p4.y);
    ctx.lineTo(p3.x, p3.y);
    ctx.closePath();
    ctx.clip();

    if (imgs.road) {
      // slower texture flow
      const scroll = (z * 0.18 + game.dist * 0.20) % 320;
      // 180Â° rotated road texture
      const minX = Math.min(p1.x, p2.x, p3.x, p4.x);
      const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
      const minY = Math.min(p1.y, p2.y, p3.y, p4.y);
      const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);
      const w = (maxX - minX) + 130;
      const h = (maxY - minY) + 520;
      const cx = (minX + maxX) * 0.5;
      const cy = (minY + maxY) * 0.5;
      ctx.translate(cx, cy);
      ctx.rotate(Math.PI);
      drawImageSafe("road", -w * 0.5, -h * 0.5 - scroll, w, h, "#474333");
    } else {
      ctx.fillStyle = (Math.floor(z / cfg.segmentLength) % 2 === 0) ? "#3f3c2d" : "#4d4a39";
      ctx.fillRect(p3.x, p3.y, p4.x - p3.x, p1.y - p3.y + 2);
    }
    ctx.restore();
  }
}

function drawEntity(e) {
  const relZ = e.z - game.dist;
  const p = project(laneOffset(e.lane), relZ);

  if (e.type === "coin") {
    const s = Math.max(16, p.scale * 96);
    drawImageSafe("coin", p.x - s / 2, p.y - s * 1.1, s, s, "#ffc844");
  } else if (e.type === "powerup") {
    const s = Math.max(20, p.scale * 112);
    drawImageSafe(e.variant, p.x - s / 2, p.y - s * 1.1, s, s, "#79ffe2");
  } else {
    const w = Math.max(36, p.scale * 182);
    const h = Math.max(44, p.scale * 206);
    drawImageSafe(e.variant, p.x - w / 2, p.y - h, w, h, "#2a7d3a");
  }
}

function drawPlayer() {
  const p = project(laneOffset(player.laneSmooth), cfg.playerDepth);
  const w = 94;
  const h = 115;
  drawImageSafe("player", p.x - w / 2, p.y - h + player.y, w, h, "#ff5a5a");
}

function drawHUD() {
  ctx.fillStyle = "rgba(0,0,0,.38)";
  ctx.fillRect(14, 14, 250, 96);
  ctx.fillStyle = "#fff";
  ctx.font = "600 18px sans-serif";
  ctx.fillText(`Score: ${Math.floor(game.score)}`, 24, 42);
  ctx.fillText(`Coins: ${game.coins}`, 24, 68);
  ctx.fillText(`Speed: ${Math.floor(game.speed)}`, 24, 94);

  if (!game.running) {
    ctx.fillStyle = "rgba(0,0,0,.65)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "700 44px sans-serif";
    ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 12);
    ctx.font = "500 22px sans-serif";
    ctx.fillText("Press Enter to restart", canvas.width / 2, canvas.height / 2 + 30);
    ctx.textAlign = "start";
  }
}

function update(dt) {
  player.laneSmooth = lerp(player.laneSmooth, cfg.laneX[player.lane], clamp(dt * 12, 0, 1));
  player.vy += player.gravity * dt;
  player.y += player.vy * dt;
  if (player.y >= 0) { player.y = 0; player.vy = 0; player.grounded = true; }

  if (!game.running) return;

  game.speed = Math.min(cfg.speedMax, game.speed + cfg.accel * dt);
  const dz = game.speed * dt;
  game.dist += dz;
  game.score += dz * 0.1;
  game.magnet = Math.max(0, game.magnet - dt);
  game.shield = Math.max(0, game.shield - dt);

  while (game.nextSpawn < game.dist + cfg.drawDistance + 1200) spawnWave();

  for (const e of entities) {
    if (e.dead) continue;
    const relZ = e.z - game.dist;

    if (e.type === "coin" && game.magnet > 0 && relZ < 450) e.lane = lerp(e.lane, player.laneSmooth, clamp(dt * 4, 0, 1));

    const near = relZ > cfg.playerDepth - 78 && relZ < cfg.playerDepth + 68;
    const laneHit = Math.abs(e.lane - player.laneSmooth) < 0.45;
    if (!near || !laneHit) continue;

    if (e.type === "coin") {
      e.dead = true;
      game.coins += 1;
      game.score += 50;
    } else if (e.type === "powerup") {
      e.dead = true;
      if (e.variant === "magnet") game.magnet = 7;
      if (e.variant === "shield") game.shield = 6;
    } else {
      const gapNeedsJump = e.variant === "gap";
      const jumping = player.y < -30;
      const hit = gapNeedsJump ? !jumping : jumping ? false : true;
      if (hit && game.shield <= 0) game.running = false;
    }
  }

  for (let i = entities.length - 1; i >= 0; i--) {
    const relZ = entities[i].z - game.dist;
    if (entities[i].dead || relZ < -380) entities.splice(i, 1);
  }
}

function render() {
  if (imgs.background) drawImageSafe("background", 0, 0, canvas.width, canvas.height * 0.66);
  else {
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.8);
    g.addColorStop(0, "#4fb56e");
    g.addColorStop(1, "#143321");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  drawRoad();

  const visible = entities
    .filter(e => e.z - game.dist > -350 && e.z - game.dist < cfg.drawDistance)
    .sort((a, b) => b.z - a.z);

  for (const e of visible) drawEntity(e);
  drawPlayer();
  drawHUD();
}

function loop(now) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

document.addEventListener("keydown", (e) => {
  if (e.code === "ArrowLeft" && game.running) player.lane = Math.max(0, player.lane - 1);
  if (e.code === "ArrowRight" && game.running) player.lane = Math.min(2, player.lane + 1);
  if ((e.code === "ArrowUp" || e.code === "Space") && game.running && player.grounded) {
    player.vy = player.jumpVel;
    player.grounded = false;
  }
  if (e.code === "Enter" && !game.running) reset();
});

document.addEventListener("keyup", (e) => {
  if ((e.code === "ArrowUp" || e.code === "Space") && player.vy < 0) player.vy *= 0.45;
});

loadAssets().then(() => {
  reset();
  requestAnimationFrame(loop);
});
</script>
</body>
</html>
