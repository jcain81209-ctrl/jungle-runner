<!DOCTYPE html>
<html>
<head>
<title>Jungle Runner Engine Rebuild</title>
<style>
body { margin:0; overflow:hidden; background:black; }
canvas { display:block; margin:auto; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = 800;
canvas.height = 600;

/* =========================
   CAMERA + WORLD SETTINGS
========================= */

const horizon = 150;
const cameraDepth = 300;
const roadWidth = 600;
const segmentLength = 200;

let speed = 8;
let score = 0;

/* =========================
   PLAYER (fixed depth)
========================= */

let player = {
  lane: 0,
  z: 0,
  y: 0,
  velocityY: 0,
  gravity: 0.6,
  jumpPower: -12,
  grounded: true
};

const lanes = [-1, 0, 1];

/* =========================
   OBJECTS
========================= */

let obstacles = [];

/* =========================
   SPAWN
========================= */

function spawnObstacle(){
  obstacles.push({
    lane: lanes[Math.floor(Math.random()*3)],
    z: 2000
  });
}

/* =========================
   PERSPECTIVE FUNCTION
========================= */

function project(x, z){

  const scale = cameraDepth / (cameraDepth + z);

  const screenX = canvas.width/2 + x * scale;
  const screenY = horizon + (z * scale);

  return { scale, screenX, screenY };
}

/* =========================
   DRAW ROAD
========================= */

function drawRoad(){

  for(let z=0; z<2000; z+=segmentLength){

    const p1 = project(-roadWidth/2, z);
    const p2 = project( roadWidth/2, z);

    const p3 = project(-roadWidth/2, z+segmentLength);
    const p4 = project( roadWidth/2, z+segmentLength);

    ctx.fillStyle = (Math.floor(z/segmentLength)%2===0) ? "#444" : "#555";

    ctx.beginPath();
    ctx.moveTo(p1.screenX, p1.screenY);
    ctx.lineTo(p2.screenX, p2.screenY);
    ctx.lineTo(p4.screenX, p4.screenY);
    ctx.lineTo(p3.screenX, p3.screenY);
    ctx.closePath();
    ctx.fill();
  }
}

/* =========================
   UPDATE PLAYER
========================= */

function updatePlayer(){

  player.velocityY += player.gravity;
  player.y += player.velocityY;

  if(player.y >= 0){
    player.y = 0;
    player.velocityY = 0;
    player.grounded = true;
  }
}

/* =========================
   DRAW PLAYER
========================= */

function drawPlayer(){

  const laneOffset = lanes[player.lane] * (roadWidth/3);
  const p = project(laneOffset, 0);

  const width = 40;
  const height = 80;

  ctx.fillStyle = "red";
  ctx.fillRect(
    p.screenX - width/2,
    p.screenY - height + player.y,
    width,
    height
  );
}

/* =========================
   UPDATE OBSTACLES
========================= */

function updateObstacles(){

  obstacles.forEach((o,i)=>{

    o.z -= speed;

    const laneOffset = o.lane * (roadWidth/3);
    const p = project(laneOffset, o.z);

    const size = 60 * p.scale;

    ctx.fillStyle="green";
    ctx.fillRect(
      p.screenX - size/2,
      p.screenY - size,
      size,
      size
    );

    // Collision
    if(o.z < 100 && o.z > -50){
      if(o.lane === lanes[player.lane] && player.y === 0){
        alert("Game Over! Score: "+score);
        location.reload();
      }
    }

    if(o.z < -200) obstacles.splice(i,1);

  });
}

/* =========================
   CONTROLS
========================= */

document.addEventListener("keydown", e=>{
  if(e.code==="ArrowLeft" && player.lane>0) player.lane--;
  if(e.code==="ArrowRight" && player.lane<2) player.lane++;
  if(e.code==="Space" && player.grounded){
    player.velocityY = player.jumpPower;
    player.grounded=false;
  }
});

/* =========================
   GAME LOOP
========================= */

let spawnTimer = 0;

function loop(){

  ctx.clearRect(0,0,canvas.width,canvas.height);

  drawRoad();
  updatePlayer();
  drawPlayer();
  updateObstacles();

  spawnTimer++;
  if(spawnTimer > 100){
    spawnObstacle();
    spawnTimer=0;
  }

  score++;

  requestAnimationFrame(loop);
}

loop();

</script>
</body>
</html>
