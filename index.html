 <!DOCTYPE html>
-<html>
+<html lang="en">
 <head>
+<meta charset="UTF-8" />
+<meta name="viewport" content="width=device-width, initial-scale=1.0" />
 <title>Jungle Runner Engine Rebuild</title>
 <style>
-body { margin:0; overflow:hidden; background:black; }
-canvas { display:block; margin:auto; }
+  :root {
+    color-scheme: dark;
+  }
+
+  * {
+    box-sizing: border-box;
+  }
+
+  body {
+    margin: 0;
+    min-height: 100vh;
+    display: grid;
+    place-items: center;
+    background: radial-gradient(circle at 50% 10%, #203b24, #09110c 75%);
+    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
+  }
+
+  canvas {
+    display: block;
+    border: 2px solid rgba(255, 255, 255, 0.2);
+    border-radius: 14px;
+    box-shadow: 0 24px 80px rgba(0, 0, 0, 0.6);
+    max-width: min(96vw, 1200px);
+    height: auto;
+  }
 </style>
 </head>
 <body>
-<canvas id="game"></canvas>
+<canvas id="game" width="960" height="540"></canvas>
 <script>
-
 const canvas = document.getElementById("game");
 const ctx = canvas.getContext("2d");
 
-canvas.width = 800;
-canvas.height = 600;
-
-/* =========================
-   CAMERA + WORLD SETTINGS
-========================= */
+const config = {
+  cameraDepth: 380,
+  horizon: 110,
+  roadWidth: 740,
+  laneCount: 3,
+  segmentLength: 160,
+  worldDrawDistance: 4200,
+  minSpawnDistance: 1100,
+  maxSpawnDistance: 2100,
+  initialSpeed: 420,
+  maxSpeed: 880,
+  acceleration: 8,
+};
 
-const horizon = 150;
-const cameraDepth = 300;
-const roadWidth = 600;
-const segmentLength = 200;
+const lanes = [-1, 0, 1];
 
-let speed = 8;
-let score = 0;
+const images = {
+  player: loadImage("assets/player.png"),
+  road: loadImage("assets/road.png"),
+  tree: loadImage("assets/tree.png"),
+  coin: loadImage("assets/coin.png"),
+  background: loadImage("assets/background.png"),
+};
 
-/* =========================
-   PLAYER (fixed depth)
-========================= */
+const game = {
+  running: true,
+  score: 0,
+  distance: 0,
+  coins: 0,
+  bestScore: Number(localStorage.getItem("jungleRunnerBest") || 0),
+  speed: config.initialSpeed,
+  nextSpawnZ: 1200,
+  elapsed: 0,
+};
 
-let player = {
-  lane: 0,
-  z: 0,
+const player = {
+  laneIndex: 1,
+  laneVisual: 0,
+  laneSwitchSpeed: 9,
   y: 0,
   velocityY: 0,
-  gravity: 0.6,
-  jumpPower: -12,
-  grounded: true
+  gravity: 2500,
+  jumpVelocity: -1080,
+  jumpCutMultiplier: 0.45,
+  grounded: true,
+  invulnerableTime: 0,
 };
 
-const lanes = [-1, 0, 1];
-
-/* =========================
-   OBJECTS
-========================= */
-
-let obstacles = [];
-
-/* =========================
-   SPAWN
-========================= */
+const entities = [];
+let previousTime = performance.now();
 
-function spawnObstacle(){
-  obstacles.push({
-    lane: lanes[Math.floor(Math.random()*3)],
-    z: 2000
-  });
+function loadImage(src) {
+  const img = new Image();
+  img.src = src;
+  return img;
 }
 
-/* =========================
-   PERSPECTIVE FUNCTION
-========================= */
-
-function project(x, z){
+function randomRange(min, max) {
+  return min + Math.random() * (max - min);
+}
 
-  const scale = cameraDepth / (cameraDepth + z);
+function lerp(a, b, t) {
+  return a + (b - a) * t;
+}
 
-  const screenX = canvas.width/2 + x * scale;
-  const screenY = horizon + (z * scale);
+function approach(a, b, amount) {
+  if (a < b) return Math.min(a + amount, b);
+  if (a > b) return Math.max(a - amount, b);
+  return a;
+}
 
+function project(worldX, worldZ) {
+  const scale = config.cameraDepth / (config.cameraDepth + Math.max(worldZ, -config.cameraDepth + 1));
+  const screenX = canvas.width * 0.5 + worldX * scale;
+  const screenY = config.horizon + worldZ * scale;
   return { scale, screenX, screenY };
 }
 
-/* =========================
-   DRAW ROAD
-========================= */
-
-function drawRoad(){
-
-  for(let z=0; z<2000; z+=segmentLength){
-
-    const p1 = project(-roadWidth/2, z);
-    const p2 = project( roadWidth/2, z);
+function laneOffsetFromValue(laneValue) {
+  return laneValue * (config.roadWidth / config.laneCount);
+}
 
-    const p3 = project(-roadWidth/2, z+segmentLength);
-    const p4 = project( roadWidth/2, z+segmentLength);
+function spawnEntity(type, lane, z) {
+  entities.push({ type, lane, z, collected: false });
+}
 
-    ctx.fillStyle = (Math.floor(z/segmentLength)%2===0) ? "#444" : "#555";
+function spawnPattern() {
+  const lane = lanes[Math.floor(Math.random() * lanes.length)];
+  spawnEntity("obstacle", lane, game.nextSpawnZ);
 
-    ctx.beginPath();
-    ctx.moveTo(p1.screenX, p1.screenY);
-    ctx.lineTo(p2.screenX, p2.screenY);
-    ctx.lineTo(p4.screenX, p4.screenY);
-    ctx.lineTo(p3.screenX, p3.screenY);
-    ctx.closePath();
-    ctx.fill();
+  if (Math.random() > 0.35) {
+    const coinLane = lanes[Math.floor(Math.random() * lanes.length)];
+    const stack = Math.floor(randomRange(2, 5));
+    for (let i = 0; i < stack; i++) {
+      spawnEntity("coin", coinLane, game.nextSpawnZ + 180 + i * 110);
+    }
   }
+
+  game.nextSpawnZ += randomRange(config.minSpawnDistance, config.maxSpawnDistance);
 }
 
-/* =========================
-   UPDATE PLAYER
-========================= */
+function resetGame() {
+  game.running = true;
+  game.score = 0;
+  game.distance = 0;
+  game.coins = 0;
+  game.speed = config.initialSpeed;
+  game.nextSpawnZ = 1200;
+  game.elapsed = 0;
+  entities.length = 0;
+
+  player.laneIndex = 1;
+  player.laneVisual = 0;
+  player.y = 0;
+  player.velocityY = 0;
+  player.grounded = true;
+  player.invulnerableTime = 1.3;
+
+  for (let i = 0; i < 4; i++) spawnPattern();
+}
 
-function updatePlayer(){
+function updatePlayer(dt) {
+  const laneTarget = lanes[player.laneIndex];
+  player.laneVisual = approach(player.laneVisual, laneTarget, dt * player.laneSwitchSpeed);
 
-  player.velocityY += player.gravity;
-  player.y += player.velocityY;
+  player.velocityY += player.gravity * dt;
+  player.y += player.velocityY * dt;
 
-  if(player.y >= 0){
+  if (player.y >= 0) {
     player.y = 0;
     player.velocityY = 0;
     player.grounded = true;
   }
+
+  player.invulnerableTime = Math.max(0, player.invulnerableTime - dt);
 }
 
-/* =========================
-   DRAW PLAYER
-========================= */
+function updateWorld(dt) {
+  if (!game.running) return;
 
-function drawPlayer(){
+  game.elapsed += dt;
+  game.speed = Math.min(config.maxSpeed, game.speed + config.acceleration * dt * 12);
+  const dz = game.speed * dt;
 
-  const laneOffset = lanes[player.lane] * (roadWidth/3);
-  const p = project(laneOffset, 0);
+  game.distance += dz;
+  game.score += dz * 0.1;
 
-  const width = 40;
-  const height = 80;
+  entities.forEach((entity) => {
+    entity.z -= dz;
+  });
 
-  ctx.fillStyle = "red";
-  ctx.fillRect(
-    p.screenX - width/2,
-    p.screenY - height + player.y,
-    width,
-    height
-  );
-}
+  while (game.nextSpawnZ < config.worldDrawDistance) {
+    spawnPattern();
+  }
 
-/* =========================
-   UPDATE OBSTACLES
-========================= */
+  for (const entity of entities) {
+    const laneMatch = Math.abs(entity.lane - player.laneVisual) < 0.42;
+    const nearPlayer = entity.z < 120 && entity.z > -40;
+    if (!nearPlayer || !laneMatch || entity.collected) continue;
+
+    if (entity.type === "coin") {
+      entity.collected = true;
+      game.coins += 1;
+      game.score += 55;
+    } else if (entity.type === "obstacle" && player.y > -28 && player.invulnerableTime <= 0) {
+      game.running = false;
+      game.bestScore = Math.max(game.bestScore, Math.floor(game.score));
+      localStorage.setItem("jungleRunnerBest", String(game.bestScore));
+    }
+  }
 
-function updateObstacles(){
+  for (let i = entities.length - 1; i >= 0; i--) {
+    if (entities[i].z < -220 || entities[i].collected) entities.splice(i, 1);
+  }
+}
 
-  obstacles.forEach((o,i)=>{
+function drawSky() {
+  if (images.background.complete) {
+    ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height * 0.62);
+  } else {
+    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.68);
+    gradient.addColorStop(0, "#4bb073");
+    gradient.addColorStop(1, "#183424");
+    ctx.fillStyle = gradient;
+    ctx.fillRect(0, 0, canvas.width, canvas.height * 0.68);
+  }
 
-    o.z -= speed;
+  ctx.fillStyle = "rgba(10,16,11,0.75)";
+  ctx.fillRect(0, config.horizon + 240, canvas.width, canvas.height);
+}
 
-    const laneOffset = o.lane * (roadWidth/3);
-    const p = project(laneOffset, o.z);
+function drawRoad() {
+  for (let z = 0; z < config.worldDrawDistance; z += config.segmentLength) {
+    const near = project(-config.roadWidth * 0.5, z);
+    const nearRight = project(config.roadWidth * 0.5, z);
+    const far = project(-config.roadWidth * 0.5, z + config.segmentLength);
+    const farRight = project(config.roadWidth * 0.5, z + config.segmentLength);
 
-    const size = 60 * p.scale;
+    const stripe = (Math.floor((z + game.distance * 0.7) / config.segmentLength) % 2) === 0;
+    ctx.fillStyle = stripe ? "#3c3a2d" : "#4b493a";
 
-    ctx.fillStyle="green";
-    ctx.fillRect(
-      p.screenX - size/2,
-      p.screenY - size,
-      size,
-      size
-    );
+    ctx.beginPath();
+    ctx.moveTo(near.screenX, near.screenY);
+    ctx.lineTo(nearRight.screenX, nearRight.screenY);
+    ctx.lineTo(farRight.screenX, farRight.screenY);
+    ctx.lineTo(far.screenX, far.screenY);
+    ctx.closePath();
+    ctx.fill();
+
+    ctx.strokeStyle = "rgba(255,255,255,0.09)";
+    ctx.beginPath();
+    ctx.moveTo(lerp(near.screenX, nearRight.screenX, 1/3), near.screenY);
+    ctx.lineTo(lerp(far.screenX, farRight.screenX, 1/3), far.screenY);
+    ctx.moveTo(lerp(near.screenX, nearRight.screenX, 2/3), near.screenY);
+    ctx.lineTo(lerp(far.screenX, farRight.screenX, 2/3), far.screenY);
+    ctx.stroke();
+  }
+}
 
-    // Collision
-    if(o.z < 100 && o.z > -50){
-      if(o.lane === lanes[player.lane] && player.y === 0){
-        alert("Game Over! Score: "+score);
-        location.reload();
-      }
+function drawEntity(entity) {
+  const x = laneOffsetFromValue(entity.lane);
+  const p = project(x, entity.z);
+
+  if (entity.type === "coin") {
+    const size = Math.max(14, p.scale * 100);
+    if (images.coin.complete) {
+      ctx.drawImage(images.coin, p.screenX - size * 0.5, p.screenY - size * 1.15, size, size);
+    } else {
+      ctx.fillStyle = "#ffd24a";
+      ctx.beginPath();
+      ctx.arc(p.screenX, p.screenY - size * 0.55, size * 0.35, 0, Math.PI * 2);
+      ctx.fill();
     }
+    return;
+  }
 
-    if(o.z < -200) obstacles.splice(i,1);
+  const w = Math.max(28, p.scale * 170);
+  const h = Math.max(35, p.scale * 195);
 
-  });
+  if (images.tree.complete) {
+    ctx.drawImage(images.tree, p.screenX - w * 0.5, p.screenY - h * 1.05, w, h);
+  } else {
+    ctx.fillStyle = "#1c6f35";
+    ctx.fillRect(p.screenX - w * 0.5, p.screenY - h, w, h);
+  }
 }
 
-/* =========================
-   CONTROLS
-========================= */
+function drawPlayer() {
+  const x = laneOffsetFromValue(player.laneVisual);
+  const p = project(x, 0);
+  const w = 84;
+  const h = 102;
+
+  const yOffset = player.y;
 
-document.addEventListener("keydown", e=>{
-  if(e.code==="ArrowLeft" && player.lane>0) player.lane--;
-  if(e.code==="ArrowRight" && player.lane<2) player.lane++;
-  if(e.code==="Space" && player.grounded){
-    player.velocityY = player.jumpPower;
-    player.grounded=false;
+  ctx.save();
+  if (player.invulnerableTime > 0 && Math.floor(player.invulnerableTime * 24) % 2 === 0) {
+    ctx.globalAlpha = 0.45;
   }
-});
 
-/* =========================
-   GAME LOOP
-========================= */
+  if (images.player.complete) {
+    ctx.drawImage(images.player, p.screenX - w * 0.5, p.screenY - h + yOffset, w, h);
+  } else {
+    ctx.fillStyle = "#f44949";
+    ctx.fillRect(p.screenX - w * 0.5, p.screenY - h + yOffset, w, h);
+  }
+  ctx.restore();
+}
 
-let spawnTimer = 0;
+function drawHud() {
+  ctx.fillStyle = "rgba(0,0,0,0.36)";
+  ctx.fillRect(16, 16, 280, 104);
+
+  ctx.fillStyle = "#f5f5f5";
+  ctx.font = "600 20px Inter, sans-serif";
+  ctx.fillText(`Score: ${Math.floor(game.score)}`, 28, 46);
+  ctx.fillText(`Best: ${game.bestScore}`, 28, 74);
+  ctx.fillText(`Coins: ${game.coins}`, 28, 102);
+
+  if (!game.running) {
+    ctx.fillStyle = "rgba(0,0,0,0.65)";
+    ctx.fillRect(0, 0, canvas.width, canvas.height);
+
+    ctx.fillStyle = "#fff";
+    ctx.textAlign = "center";
+    ctx.font = "700 48px Inter, sans-serif";
+    ctx.fillText("Run Over", canvas.width / 2, canvas.height / 2 - 36);
+
+    ctx.font = "500 22px Inter, sans-serif";
+    ctx.fillText(`Final Score: ${Math.floor(game.score)}`, canvas.width / 2, canvas.height / 2 + 4);
+    ctx.fillText("Press Enter to restart", canvas.width / 2, canvas.height / 2 + 46);
+    ctx.textAlign = "start";
+  }
+}
 
-function loop(){
+function draw() {
+  ctx.clearRect(0, 0, canvas.width, canvas.height);
+  drawSky();
+  drawRoad();
 
-  ctx.clearRect(0,0,canvas.width,canvas.height);
+  const sorted = [...entities].sort((a, b) => b.z - a.z);
+  sorted.forEach(drawEntity);
 
-  drawRoad();
-  updatePlayer();
   drawPlayer();
-  updateObstacles();
+  drawHud();
+}
 
-  spawnTimer++;
-  if(spawnTimer > 100){
-    spawnObstacle();
-    spawnTimer=0;
-  }
+function tick(now) {
+  const dt = Math.min(0.033, (now - previousTime) / 1000);
+  previousTime = now;
 
-  score++;
+  updatePlayer(dt);
+  updateWorld(dt);
+  draw();
 
-  requestAnimationFrame(loop);
+  requestAnimationFrame(tick);
 }
 
-loop();
+document.addEventListener("keydown", (event) => {
+  if (event.code === "ArrowLeft" && game.running) {
+    player.laneIndex = Math.max(0, player.laneIndex - 1);
+  } else if (event.code === "ArrowRight" && game.running) {
+    player.laneIndex = Math.min(config.laneCount - 1, player.laneIndex + 1);
+  } else if ((event.code === "ArrowUp" || event.code === "Space") && game.running && player.grounded) {
+    player.velocityY = player.jumpVelocity;
+    player.grounded = false;
+  } else if (event.code === "Enter" && !game.running) {
+    resetGame();
+  }
+});
+
+document.addEventListener("keyup", (event) => {
+  if ((event.code === "ArrowUp" || event.code === "Space") && player.velocityY < 0) {
+    player.velocityY *= player.jumpCutMultiplier;
+  }
+});
 
+resetGame();
+requestAnimationFrame(tick);
 </script>
 </body>
 </html>
 
EOF
)
