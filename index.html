<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jungle Runner</title>
  <style>
    body { margin: 0; min-height: 100vh; display: grid; place-items: center; background: #0b120d; }
    canvas { width: min(96vw, 1200px); height: auto; border: 2px solid rgba(255,255,255,.22); border-radius: 14px; }
  </style>
</head>
<body>
<canvas id="game" width="960" height="540"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const cfg = {
  horizonY: 132,
  cameraDepth: 430,
  roadWidth: 740,
  drawDistance: 5200,
  laneX: [-1, 0, 1],
  playerDepth: 430,
  speedStart: 220,
  speedMax: 500,
  accel: 30,
  spawnGapMin: 500,
  spawnGapMax: 760,
  collisionNearMin: -30,
  collisionNearMax: 95,
};

const imgPaths = {
  background: "assets/background.png",
  road: "assets/road.png",
  player: "assets/player.png",
  tree: "assets/tree.png",
  wall: "assets/wall.png",
  gap: "assets/gap.png",
  coin: "assets/coin.png",
  magnet: "assets/magnet.png",
  shield: "assets/shield.png"
};

const imgs = {};
let roadPattern = null;
const game = {
  running: true,
  speed: cfg.speedStart,
  dist: 0,
  score: 0,
  coins: 0,
  nextSpawn: 1200,
  spawnTick: 0,
  magnet: 0,
  shield: 0,
};

const player = {
  lane: 1,
  laneSmooth: 0,
  y: 0,
  vy: 0,
  grounded: true,
  jumpVel: -1030,
  gravity: 2500,
};

const entities = [];
let last = performance.now();

function loadAssets() {
  const jobs = Object.entries(imgPaths).map(([k, src]) => new Promise((res) => {
    const i = new Image();
    i.onload = () => {
      imgs[k] = i;
      if (k === "road") roadPattern = ctx.createPattern(i, "repeat-y");
      res();
    };
    i.onerror = () => res();
    i.src = src;
  }));
  return Promise.all(jobs);
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function rr(min, max) { return min + Math.random() * (max - min); }
function laneOffset(v) { return v * (cfg.roadWidth / 3); }

function project(worldX, relZ) {
  const z = Math.max(relZ, 1);
  const s = cfg.cameraDepth / (cfg.cameraDepth + z);
  const y = cfg.horizonY + s * (canvas.height - cfg.horizonY);
  return { x: canvas.width * 0.5 + worldX * s, y, scale: s };
}

function addEntity(type, lane, z, variant = "") {
  entities.push({ type, lane, z, variant, dead: false });
}

function spawnWave() {
  // Spawn entities in the middle lane so they enter from top-center and scroll downward.
  const centerLane = 0;
  const r = Math.random();
  addEntity("obstacle", centerLane, game.nextSpawn, r < 0.42 ? "tree" : (r < 0.82 ? "wall" : "gap"));

  const coinCount = 4 + Math.floor(Math.random() * 3);
  for (let i = 0; i < coinCount; i++) addEntity("coin", centerLane, game.nextSpawn + 120 + i * 90);

  game.spawnTick += 1;
  if (game.spawnTick % 2 === 0) {
    addEntity("powerup", centerLane, game.nextSpawn + 250, game.spawnTick % 4 === 0 ? "shield" : "magnet");
  }

  game.nextSpawn += rr(cfg.spawnGapMin, cfg.spawnGapMax);
}

function reset() {
  game.running = true;
  game.speed = cfg.speedStart;
  game.dist = 0;
  game.score = 0;
  game.coins = 0;
  game.nextSpawn = 1200;
  game.spawnTick = 0;
  game.magnet = 0;
  game.shield = 0;
  entities.length = 0;
  player.lane = 1;
  player.laneSmooth = 0;
  player.y = 0;
  player.vy = 0;
  player.grounded = true;
  while (game.nextSpawn < cfg.drawDistance + 1000) spawnWave();
}

function drawImageSafe(key, x, y, w, h, fallback = "#555") {
  if (imgs[key]) ctx.drawImage(imgs[key], x, y, w, h);
  else { ctx.fillStyle = fallback; ctx.fillRect(x, y, w, h); }
}

function drawSkyAndBlend() {
  if (imgs.background) {
    drawImageSafe("background", 0, 0, canvas.width, canvas.height);
  } else {
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, "#4fb56e");
    g.addColorStop(1, "#143321");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  const blend = ctx.createLinearGradient(0, cfg.horizonY - 24, 0, cfg.horizonY + 140);
  blend.addColorStop(0, "rgba(18,58,36,0)");
  blend.addColorStop(1, "rgba(18,58,36,0.55)");
  ctx.fillStyle = blend;
  ctx.fillRect(0, cfg.horizonY - 24, canvas.width, 200);
}

function drawRoad() {
  const far = project(0, cfg.drawDistance);
  const nearRight = project(cfg.roadWidth * 0.5, 0);
  const nearLeftX = canvas.width - nearRight.x;

  const topY = far.y;
  const botY = canvas.height + 10;
  const topHalf = 28;
  const botHalf = Math.max(Math.max(nearRight.x - canvas.width * 0.5, canvas.width * 0.5 - nearLeftX), 340);

  ctx.save();
  ctx.beginPath();
  ctx.moveTo(canvas.width * 0.5 - topHalf, topY);
  ctx.lineTo(canvas.width * 0.5 + topHalf, topY);
  ctx.lineTo(canvas.width * 0.5 + botHalf, botY);
  ctx.lineTo(canvas.width * 0.5 - botHalf, botY);
  ctx.closePath();
  ctx.clip();

  if (roadPattern) {
    ctx.translate(canvas.width * 0.5, (topY + botY) * 0.5);
    const scroll = (game.dist * 0.36) % 512;
    ctx.translate(0, scroll);
    ctx.fillStyle = roadPattern;
    ctx.fillRect(-1100, -1400, 2200, 2800);
  } else {
    const g = ctx.createLinearGradient(0, topY, 0, botY);
    g.addColorStop(0, "#5f5740");
    g.addColorStop(1, "#3d3728");
    ctx.fillStyle = g;
    ctx.fillRect(0, topY, canvas.width, botY - topY);
  }

  // Deep blend pass: merge road into background with perspective fade and side feathering.
  const depthFade = ctx.createLinearGradient(0, topY - 8, 0, botY);
  depthFade.addColorStop(0, "rgba(24,66,41,0.78)");
  depthFade.addColorStop(0.2, "rgba(24,66,41,0.35)");
  depthFade.addColorStop(0.5, "rgba(18,50,32,0.16)");
  depthFade.addColorStop(1, "rgba(8,16,11,0.06)");
  ctx.fillStyle = depthFade;
  ctx.fillRect(canvas.width * 0.5 - botHalf, topY - 12, botHalf * 2, botY - topY + 20);

  const sideFade = ctx.createLinearGradient(canvas.width * 0.5 - botHalf, 0, canvas.width * 0.5 + botHalf, 0);
  sideFade.addColorStop(0, "rgba(15,36,24,0.52)");
  sideFade.addColorStop(0.16, "rgba(15,36,24,0.18)");
  sideFade.addColorStop(0.5, "rgba(0,0,0,0)");
  sideFade.addColorStop(0.84, "rgba(15,36,24,0.18)");
  sideFade.addColorStop(1, "rgba(15,36,24,0.52)");
  ctx.fillStyle = sideFade;
  ctx.fillRect(canvas.width * 0.5 - botHalf, topY - 12, botHalf * 2, botY - topY + 20);

  ctx.restore();

  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(canvas.width * 0.5 - botHalf / 3, botY);
  ctx.lineTo(canvas.width * 0.5 - topHalf / 3, topY);
  ctx.moveTo(canvas.width * 0.5 + botHalf / 3, botY);
  ctx.lineTo(canvas.width * 0.5 + topHalf / 3, topY);
  ctx.stroke();
}


function drawEntity(e) {
  const relZ = e.z - game.dist;
  const p = project(laneOffset(e.lane), relZ);

  if (e.type === "coin") {
    const s = Math.max(16, p.scale * 96);
    drawImageSafe("coin", p.x - s / 2, p.y - s * 1.1, s, s, "#ffc844");
  } else if (e.type === "powerup") {
    const s = Math.max(20, p.scale * 112);
    drawImageSafe(e.variant, p.x - s / 2, p.y - s * 1.1, s, s, "#79ffe2");
  } else {
    const w = Math.max(40, p.scale * 196);
    const h = Math.max(54, p.scale * 222);
    drawImageSafe(e.variant, p.x - w / 2, p.y - h, w, h, "#2a7d3a");
  }
}

function drawPlayer() {
  const p = project(laneOffset(player.laneSmooth), cfg.playerDepth);
  const w = 96;
  const h = 118;
  const baseY = canvas.height - h - 2;
  drawImageSafe("player", p.x - w / 2, baseY + player.y, w, h, "#ff5a5a");
}


function drawHUD() {
  ctx.fillStyle = "rgba(0,0,0,.38)";
  ctx.fillRect(14, 14, 330, 124);
  ctx.fillStyle = "#fff";
  ctx.font = "600 18px sans-serif";
  ctx.fillText(`Score: ${Math.floor(game.score)}`, 24, 42);
  ctx.fillText(`Coins: ${game.coins}`, 24, 68);
  ctx.fillText(`Speed: ${Math.floor(game.speed)}`, 24, 94);

  const activePower = game.magnet > 0 || game.shield > 0;
  const powerText = activePower
    ? `Powerup: ${game.magnet > game.shield ? "Magnet" : "Shield"} (${Math.max(game.magnet, game.shield).toFixed(1)}s)`
    : "Powerup: none";
  ctx.fillText(powerText, 24, 118);

  if (!game.running) {
    ctx.fillStyle = "rgba(0,0,0,.65)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "700 44px sans-serif";
    ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 12);
    ctx.font = "500 22px sans-serif";
    ctx.fillText("Press Enter to restart", canvas.width / 2, canvas.height / 2 + 30);
    ctx.textAlign = "start";
  }
}

function update(dt) {
  player.laneSmooth = lerp(player.laneSmooth, cfg.laneX[player.lane], clamp(dt * 12, 0, 1));
  player.vy += player.gravity * dt;
  player.y += player.vy * dt;
  if (player.y >= 0) { player.y = 0; player.vy = 0; player.grounded = true; }

  if (!game.running) return;

  game.speed = Math.min(cfg.speedMax, game.speed + cfg.accel * dt);
  const dz = game.speed * dt;
  game.dist += dz;
  game.score += dz * 0.1;
  game.magnet = Math.max(0, game.magnet - dt);
  game.shield = Math.max(0, game.shield - dt);

  while (game.nextSpawn < game.dist + cfg.drawDistance + 1200) spawnWave();

  for (const e of entities) {
    if (e.dead) continue;
    const relZ = e.z - game.dist;

    if (e.type === "coin" && game.magnet > 0 && relZ < 450) {
      e.lane = lerp(e.lane, player.laneSmooth, clamp(dt * 4, 0, 1));
    }

    const near = relZ > cfg.collisionNearMin && relZ < cfg.collisionNearMax;
    const laneHit = Math.abs(e.lane - player.laneSmooth) < 0.45;
    if (!near || !laneHit) continue;

    if (e.type === "coin") {
      e.dead = true;
      game.coins += 1;
      game.score += 50;
    } else if (e.type === "powerup") {
      e.dead = true;
      if (e.variant === "magnet") game.magnet = 7;
      if (e.variant === "shield") game.shield = 6;
    } else if (e.type === "obstacle") {
      let hit = false;
      if (e.variant === "gap") hit = player.y > -40;
      else hit = player.y > -25;
      if (hit) {
        if (game.shield > 0) {
          game.shield = 0;
          e.dead = true;
        } else {
          game.running = false;
        }
      }
    }
  }

  for (let i = entities.length - 1; i >= 0; i--) {
    const relZ = entities[i].z - game.dist;
    if (entities[i].dead || relZ < -420) entities.splice(i, 1);
  }
}

function render() {
  drawSkyAndBlend();
  drawRoad();

  const visible = entities
    .filter((e) => e.z - game.dist > -380 && e.z - game.dist < cfg.drawDistance)
    .sort((a, b) => b.z - a.z);

  for (const e of visible) drawEntity(e);
  drawPlayer();
  drawHUD();
}

function loop(now) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

document.addEventListener("keydown", (e) => {
  if (e.code === "ArrowLeft" && game.running) player.lane = Math.max(0, player.lane - 1);
  if (e.code === "ArrowRight" && game.running) player.lane = Math.min(2, player.lane + 1);
  if ((e.code === "ArrowUp" || e.code === "Space") && game.running && player.grounded) {
    player.vy = player.jumpVel;
    player.grounded = false;
  }
  if (e.code === "Enter" && !game.running) reset();
});

document.addEventListener("keyup", (e) => {
  if ((e.code === "ArrowUp" || e.code === "Space") && player.vy < 0) player.vy *= 0.45;
});

loadAssets().then(() => {
  reset();
  requestAnimationFrame(loop);
});
</script>
</body>
</html>

